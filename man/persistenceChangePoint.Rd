% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/persistenceChangePoint.R
\name{persistenceChangePoint}
\alias{persistenceChangePoint}
\title{Persistence Diagram Change Point Detection}
\usage{
persistenceChangePoint(
  multiSeries,
  maxDimension,
  maxScale,
  useWasserstein = TRUE,
  useBootstrap = FALSE,
  ...
)
}
\arguments{
\item{multiSeries}{A list of matrices, where each row of the matrix corresponds to a point in Euclidean space.}

\item{maxDimension}{Maximum dimensional topological features to detect in persistence diagram.}

\item{maxScale}{Maximum scale to consider in persistence diagrams.}

\item{useWasserstein}{set to False to use bottleneck L^\\infty distance.}

\item{useBootstrap}{set to TRUE if you want to bootstrap the change point locations. Not advisable unless the time series length is equal to a power of 2 or slighlty less than a power of 2.}

\item{...}{additional parameters passed to the distance function}
}
\value{
value The BFIC value associated with change point. Bigger than 3 is considered significant.

index The five most likely change points.
}
\description{
Computes the persistence diagrams of a time series of multi-dimensional data. Determines where the most likely change point occurs.
}
\details{
The algorithm computes the wasserstein (L^2) distance between each pair of persistence diagrams, and finds the most likely
change point in the distances. Note that the multiSeries in this case must be a *list* of matrices with N columns, where each row corresponds
to a point in R^N.
}
\examples{

Circles <- lapply(1:30, function(x) {
Circle1 <- TDA::circleUnif(60);
Circle2 <- TDA::circleUnif(60, r = 2) + 3;
rbind(Circle1, Circle2);})
Circles2 <- lapply(1:34, function(x) {
  Circle1 <- TDA::circleUnif(40);
  Circle2 <- TDA::circleUnif(40, r = 2) + 5;
  Circle3 <- TDA::circleUnif(40,r = 3) - 10;
  rbind(Circle1, Circle2, Circle3);})
Circles <- c(Circles, Circles2)
persistenceChangePoint(Circles, maxDimension = 1, maxScale = 2) #True change point at t = 31

}
